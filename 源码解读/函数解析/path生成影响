1、在top_path上创建RemoteSubPath节点，依据指定的分布重新分配数据
	Path *create_remotesubplan_path(PlannerInfo *root, Path *subpath,
							Distribution *distribution)
	{
		RelOptInfo	   *rel = subpath->parent;
		RemoteSubPath  *pathnode;
		Distribution   *subdistribution = subpath->distribution;

		pathnode = makeNode(RemoteSubPath);
		pathnode->path.pathtype = T_RemoteSubplan;
		pathnode->path.parent = rel;
		pathnode->path.param_info = subpath->param_info;
		pathnode->path.pathkeys = subpath->pathkeys;
		pathnode->subpath = subpath;
		pathnode->path.distribution = (Distribution *) copyObject(distribution);

		/* We don't want to run subplains in parallel workers */
		pathnode->path.parallel_aware = false;
		pathnode->path.parallel_safe = false;

		pathnode->path.pathtarget = subpath->pathtarget;

		cost_remote_subplan((Path *) pathnode, subpath->startup_cost,
							subpath->total_cost, subpath->rows, rel->reltarget->width,
							(subdistribution && IsLocatorReplicated(subdistribution->distributionType)) ?
							bms_num_members(subdistribution->nodes) : 1);

		return (Path *) pathnode;
	}


2、对join_path的影响
在创建join_path的函数create_hashjoin_path、create_mergejoin_path、create_nestloop_path中，都会调用函数set_joinpath_distribution来设置postgres-xl的join节点的分布方式；
在函数”set_joinpath_distribution“中，又会调用函数”redistribute_path“进行重新分布路径以匹配所需的分布参数。

/*
*分析Join参数，设置Join节点分布。
*如果存在可能的替代分发，则以列表形式返回各自的路径，以便调用者可以计算所有路径的成本，并选择最便宜继续。
*/
static List *set_joinpath_distribution(PlannerInfo *root, JoinPath *pathnode)
{
	Distribution   *innerd = pathnode->innerjoinpath->distribution;
	Distribution   *outerd = pathnode->outerjoinpath->distribution;
	Distribution   *targetd;
	List		   *alternate = NIL;
	List		   *restrictClauses = NIL;

	List		   *innerpathkeys = pathnode->innerjoinpath->pathkeys;
	List		   *outerpathkeys = pathnode->outerjoinpath->pathkeys;

	............

}




3、对scan_path的影响
在创建scan_path的函数create_seqscan_path、create_tidscan_path、create_samplescan_path、create_index_path、create_bitmap_heap_path、create_bitmap_and_path、create_bitmap_or_path中，会调用函数”set_scanpath_distribution“将distribution分配给”基本关系扫描路径“

/*
 *	Assign distribution to the path which is a base relation scan.
 */
static void set_scanpath_distribution(PlannerInfo *root, RelOptInfo *rel, Path *pathnode)
{
	RangeTblEntry   *rte;
	RelationLocInfo *rel_loc_info;

	rte = planner_rt_fetch(rel->relid, root);
	rel_loc_info = GetRelationLocInfo(rte->relid);

	.......

}











