1、在文件“src/backend/optimizer/plan/planner.c”中，修改函数“planner”，针对XC，添加如下代码
	if (IS_PGXC_LOCAL_COORDINATOR) //如果SQL语句是执行在本机CN
		result = pgxc_planner(parse, cursorOptions, boundParams);
	else


2、在文件“src/backend/optimizer/plan/planner.c”中，修改函数“standard_planner”，针对XL，添加如下代码
	if (IS_PGXC_LOCAL_COORDINATOR && parse->utilityStmt &&
			sA(parse->utilityStmt, RemoteQuery))//执行在本机CN，且时utility语句，且utility语句为RemoteQuery
	return pgxc_direct_planner(parse, cursorOptions, boundParams);


3、位于文件”src/backend/optimizer/plan/subselect.c“中，修改函数”make_subplan“，分别添加如下代码
	//针对XL
	if (subroot->distribution){//存在分布式，构建remotesubplan
		plan = (Plan *) make_remotesubplan(subroot, plan, NULL, subroot->distribution, subroot->query_pathkeys);
		plan->extParam = bms_copy(plan->lefttree->extParam);
		plan->allParam = bms_copy(plan->lefttree->allParam);
	}

	//针对XC
	if (IS_PGXC_LOCAL_COORDINATOR) //本机CN只需要一个plan，可以退出函数了
			return result;



4、位于文件”src/backend/executor/execProcnode.c”中，修改函数“ExecInitNode”，分别添加如下代码
	//针对XC
	case T_RemoteQuery:
		result = (PlanState *) ExecInitRemoteQuery((RemoteQuery *) node, estate, eflags);
		break;

	//针对XL
	case T_RemoteSubplan:
		result = (PlanState *) ExecInitRemoteSubplan((RemoteSubplan *) node, estate, eflags);
		break;



5、位于文件”src/backend/executor/execProcnode.c”中，针对XC，新增函数“ExecFinishInitProcNode”，用于循环递归调用完成初始化的最后工作


6、位于文件”src/backend/executor/execProcnode.c”中，修改函数“ExecEndNode”，分别添加如下代码
	//针对XC
	case T_RemoteQuery:
		ExecEndRemoteQuery((RemoteQueryState *) node);
		break;

	//针对XL
	case T_RemoteSubplan:
		ExecEndRemoteSubplan((RemoteSubplanState *) node);
		break;






