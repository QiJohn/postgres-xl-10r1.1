”squeue“全称”Shared queue“，基于共享内存实现session间数据交换（采用生产者、消费者模型），其中一个生产者生产的数据，同时可以被其它所有消费者读取。会话由其它DN进行初始化。生产者的的主要目的是从squeue中读取rows，然后将这些rows发送到父DN中。
	生产者通常同时也是消费者，它会将tuples发送回父节点，而不将其放入队列。
实现该squeue的文件为”src/backend/pgxc/squeue/squeue.c“




（1）================实现函数
	初始化squeue：void SharedQueuesInit(void)
		=》在”src/backend/storage/ipc/ipci.c“中，由函数”CreateSharedMemoryAndSemaphores“对共享内存、信号量进行初始化时调用

	计算squeue使用的共享内存大小：Size SharedQueueShmemSize(void)
		=》在”src/backend/storage/ipc/ipci.c“中，由函数”CreateSharedMemoryAndSemaphores“对共享内存、信号量进行初始化时调用

	保留一个命名的squeue，以便将来与进程(该进程用于向远程DN提供元组)之间进行数据交换：void SharedQueueAcquire(const char *sqname, int ncons)
		=》在”src/backend/utils/cache/plancache.c“函数”SetRemoteSubplan“中，当”中间结果需要分布在多个目的DN上“时调用

	作为消费者或生产者绑定到由 sqname 指定的共享队列：SharedQueue  SharedQueueBind(const char *sqname, List *consNodes,  List *distNodes, int *myindex, int *consMap)
		=》在”src/backend/tcop/pquery.c“函数”PortalStart“中，”绑定squeue进行数据交换“时调用

	将数据从本地tuplestore推送到指定消费者的squeue上：static bool SharedQueueDump(SharedQueue squeue, int consumerIdx, TupleTableSlot *tmpslot, Tuplestorestate *tuplestore)
		=》在”src/backend/pgxc/squeue/squeue.c“函数”SharedQueueWrite“、”SharedQueueFinish“中调用
		SharedQueueWrite --> SharedQueueDump --> sq_push_long_tuple；SharedQueueFinish --> SharedQueueDump --> sq_push_long_tuple

	将数据从slot中写入到指定消费者的squeue上，如果tuplestore存在数据则优先将tuplestore中的数据写入squeue：
		void SharedQueueWrite(SharedQueue squeue, int consumerIdx, TupleTableSlot *slot, Tuplestorestate **tuplestore, MemoryContext tmpcxt)
		=》在”src/backend/executor/producerReceiver.c“函数”producerReceiveSlot“中，调用该SharedQueueWrite在”tuple不匹配消费者queue“时，将tuple存储到本地tuplestore

	将指定squeue中的一个row数据提取到tupleslot：bool SharedQueueRead(SharedQueue squeue, int consumerIdx, TupleTableSlot *slot, bool canwait)
		=》在”src/backend/tcop/pquery.c“函数”PortalRun“中，循环调用该函数从queue中获取tuple，直到处理完plan中定义的tuple数目

	将指定的消费者标记为已关闭，丢弃可能已经在squeue中的所有输入：void SharedQueueReset(SharedQueue squeue, int consumerIdx)
		=》在”src/backend/commands/portalcmds.c“函数”PortalCleanup“中，清理portal过程中，本地执行子计划正在生成数据并通过squeue分发时调用；或者清理消费者时调用
		=》在”src/backend/tcop/pquery.c“函数”AdvanceProducingPortal“中，catch到错误时调用
		=》在”src/backend/tcop/pquery.c“函数”cleanupClosedProducers“中，catch到错误时调用

	断开给定squeue的远端消费者：void SharedQueueDisconnectConsumer(const char *sqname)
		=》在”src/backend/commands/prepare.c“函数”DropPreparedStatement“中调用

	重置没有消费者连接的squeue：void SharedQueueResetNotConnected(SharedQueue squeue)
		=》在”src/backend/executor/producerReceiver.c“函数”producerDestroyReceiver“中，squeue使用异常结束时调用
		=》在”src/backend/pgxc/squeue/squeue.c“函数”SharedQueueUnBind“中，超时时调用以实现未连接消费者的重置

	设置超时时间，等待生产者闩锁：bool SharedQueueWaitOnProducerLatch(SharedQueue squeue, long timeout)
		=》在”src/backend/executor/producerReceiver.c“函数”producerDestroyReceiver“中，squeue使用异常结束时进行设置调用

	确定生产者是否可以安全的暂停工作：bool SharedQueueCanPause(SharedQueue squeue)
		=》在”src/backend/tcop/pquery.c“函数”AdvanceProducingPortal“中，当”portal的保留存储中有可供读取的tuple，且消费者queue不为空“时，调用该函数暂停squeue，以防止在生产者处缓存过多的rows
		=》在”src/backend/tcop/pquery.c“函数”AdvanceProducingPortal“中，当”尝试dump本地tuplestores“失败时调用

	squeue使用结束：int SharedQueueFinish(SharedQueue squeue, TupleDesc tupDesc, Tuplestorestate **tuplestore)
		=》在”src/backend/executor/producerReceiver.c“函数”producerDestroyReceiver“中调用
		=》在”src/backend/executor/producerReceiver.c“函数”ProducerReceiverPushBuffers“中，”将data从本地tuplestores推送到共享内存，以供消费者使用“时调用

	解除当前进程和squeue之间的绑定：void SharedQueueUnBind(SharedQueue squeue, bool failed)
		=》在”src/backend/commands/portalcmds.c“函数”PortalCleanup“中，当”executor完成，portal->status == PORTAL_FAILED“时调用
		=》在”src/backend/executor/producerReceiver.c“函数”producerDestroyReceiver“中，当”消费者完成，释放共享资源“时调用
		=》在”src/backend/tcop/pquery.c“函数”PortalStart“中，当“调用SharedQueueBind成功后，调用ExecutorStart失败”进行解绑定时调用

	如果具有指定名称的squeue仍然存在，则将对应的消费者设置为“Done”：void SharedQueueRelease(const char *sqname)
		=》在”src/backend/utils/cache/plancache.c“函数”ReleaseGenericPlan“中，如果持有squeue，则调用该函数进行释放

	后台程序运行结束执行cleanup：void SharedQueuesCleanup(int code, Datum arg)
		=》在“src/backend/tcop/postgres.c”函数“PostgresMain”中，注册该函数，在程序退出时调用

	将数据写入squeue：static bool sq_push_long_tuple(ConsState *cstate, RemoteDataRow datarow)
		=》在”src/backend/pgxc/squeue/squeue.c“函数”SharedQueueDump“中，向消费者queue写入数据时调用

	从squeue读取long tuple：static void sq_pull_long_tuple(ConsState *cstate, RemoteDataRow datarow, int consumerIdx, SQueueSync *sqsync)
		=》在”src/backend/pgxc/squeue/squeue.c“函数”SharedQueueRead“中，至少有一行row数据，需要读取并存储到slot中时调用






（2）================squeue通信执行流程
1、构建向squeue写入数据的生产者：
exec_simple_query-->CreateDestReceiver-->CreateProducerDestReceiver
	函数”CreateProducerDestReceiver“如下所示：
		DestReceiver *CreateProducerDestReceiver(void){
			ProducerState *self = (ProducerState *) palloc0(sizeof(ProducerState));
			self->pub.receiveSlot = producerReceiveSlot;
			self->pub.rStartup = producerStartupReceiver;
			self->pub.rShutdown = producerShutdownReceiver;
			self->pub.rDestroy = producerDestroyReceiver;
			self->pub.mydest = DestProducer;

			/* private fields will be set by SetTuplestoreDestReceiverParams */
			self->tcount = 0;
			self->selfcount = 0;
			self->othercount = 0;

			return (DestReceiver *) self;
		}

2、向squeue写入数据
2.1、ExecutePlan-->(*dest->receiveSlot) (slot, dest)
		详细介绍如下所示：static void ExecutePlan(EState *estate, PlanState *planstate,	bool use_parallel_mode,	CmdType operation,	bool sendTuples,
			uint64 numberTuples, ScanDirection direction, DestReceiver *dest, bool execute_once){
				........
				for (;;){
					........
					if (sendTuples){
						if (!((*dest->receiveSlot) (slot, dest)))     //绑定函数”producerReceiveSlot“，通过"producerReceiveSlot内的SharedQueueWrite"将tuple写入squeue
							break;
					}
					........
				}
				........
		}


2.2、PortalRun-->(*dest->receiveSlot) (slot, dest)
		详细介绍如下所示：bool PortalRun(Portal portal, long count, bool isTopLevel, bool run_once, DestReceiver *dest, DestReceiver *altdest, char *completionTag){
			bool		result;
			uint64		nprocessed;
			ResourceOwner saveTopTransactionResourceOwner;
			MemoryContext saveTopTransactionContext;
			........
				for (;;){
					.........
					if (TupIsNull(slot)){
						if (!done && producing){
							/* No data to read, advance producing portals */
							ListCell   *lc = list_head(producing);
							while (lc){
								Portal p = (Portal) lfirst(lc);
								/* Get reference to next entry before
									* advancing current portal, because the
									* function may remove current entry from
									* the list.
									*/
								lc = lnext(lc);
								AdvanceProducingPortal(p, false);   //在该函数中，调用“ExecutorRun->producerReceiveSlot->SharedQueueWrite”将tuple写入到squeue中，供消费者使用
							}
							continue;
						}else{
							queryDesc->squeue = NULL;
							break;
						}
					}
					/* Send the tuple */
					(*dest->receiveSlot) (slot, dest);    //绑定函数”printtup“，通过libpq发送tuple
					if (count && count == ++nprocessed)
						break;
				}
				(*dest->rShutdown) (dest);
			........
		}
		在函数“PortalRun”中，执行步骤如下所示：
			第一步：检查portal是否使用不当，并使用函数“MarkPortalActive”将portal标记为“active”状态
			第二步：设置global portal的上下文指针
			第三步：对portal采取的策略(portal->strategy)进行判断，不同策略采用不同的处理方式
				针对“PORTAL_DISTRIBUTED”进行如下处理
					第一步：如果执行的本地subplan用于产生数据并通过squeue进行分发，则进行如下处理：
						“portal->queryDesc->squeue”不为空，则确保生产者正在推进
						“portal->queryDesc->squeue”为空，则调用函数“PortalRunSelect”获取结果的所需部分
					第二步：如果是从squeue中获取本地数据，则此时作为消费者，进行如下处理：
						第一步：调用函数“MakeSingleTupleTableSlot”，准备一个独立的slot用于接收tuples
						第二步：进入循环处理中，在循环中，调用函数“SharedQueueRead”从squeue中读取数据；当slot为空后，通过函数“AdvanceProducingPortal”调用“SharedQueueWrite”向squeue写入数据；通过函数指针“dest->receiveSlot”调用绑定的函数“printtup”进行tuple发送
						第三步：通过函数指针“dest->rShutdown”执行绑定函数
						第四步：执行函数“ExecDropSingleTupleTableSlot”释放创建的slot
					第三步：将portal标记为非激活“PORTAL_READY”状态
			第四步：使用catch对捕捉的异常进行处理



	RunFromStore
	do_tup_output



3、从squeue读数据
	PortalRun-->SharedQueueRead
		详细介绍如下所示：bool PortalRun(Portal portal, long count, bool isTopLevel, bool run_once, DestReceiver *dest, DestReceiver *altdest, char *completionTag){
			bool		result;
			uint64		nprocessed;
			ResourceOwner saveTopTransactionResourceOwner;
			MemoryContext saveTopTransactionContext;
			........
				for (;;){
					List *producing = getProducingPortals();
					bool done;
					done = SharedQueueRead(squeue, myindex, slot, list_length(producing) == 0);    //直接从squeue中获取tuple
					.........
				}
				(*dest->rShutdown) (dest);
			........
		}





（3）================日志分析
	构造subplan：plan p_1_682c_1: Remote Subplan
	创建squeue：Create a new SQueue p_1_682c_1 and format it for 1 consumers
	绑定squeue：bind p_1_682c_1 to p_1_682c_1
	创建portal：Created portal p_1_682c_1 and inserted an entry in the has table
	绑定DN：Bind node datanode_1 to squeue of step p_1_682c_1 as a producer
	SQueue p_1_682c_1 consumer @0 is set to self
	Node 1 of SQueue p_1_682c_1 is bound at consumer 0, cs_status 0
	向squeue写入数据：SQueue p_1_682c_1, consumer is active, writing data





