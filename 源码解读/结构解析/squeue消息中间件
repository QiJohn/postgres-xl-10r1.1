”squeue“全称”Shared queue“，基于共享内存实现session间数据交换（采用生产者、消费者模型），其中一个生产者生产的数据，同时可以被其它所有消费者读取。会话由其它DN进行初始化。生产者的的主要目的是从squeue中读取rows，然后将这些rows发送到父DN中。
	生产者通常同时也是消费者，它会将tuples发送回父节点，而不将其放入队列。
实现该squeue的文件为”src/backend/pgxc/squeue/squeue.c“




（1）================实现函数
	初始化squeue：void SharedQueuesInit(void)
		=》在”src/backend/storage/ipc/ipci.c“中，由函数”CreateSharedMemoryAndSemaphores“对共享内存、信号量进行初始化时调用

	计算squeue使用的共享内存大小：Size SharedQueueShmemSize(void)
		=》在”src/backend/storage/ipc/ipci.c“中，由函数”CreateSharedMemoryAndSemaphores“对共享内存、信号量进行初始化时调用

	保留一个命名的squeue，以便将来与进程(该进程用于向远程DN提供元组)之间进行数据交换：void SharedQueueAcquire(const char *sqname, int ncons)
		=》在”src/backend/utils/cache/plancache.c“函数”SetRemoteSubplan“中，当”中间结果需要分布在多个目的DN上“时调用

	作为消费者或生产者绑定到由 sqname 指定的共享队列：SharedQueue  SharedQueueBind(const char *sqname, List *consNodes,  List *distNodes, int *myindex, int *consMap)
		=》在”src/backend/tcop/pquery.c“函数”PortalStart“中，”绑定squeue进行数据交换“时调用

	将数据从本地tuplestore推送到指定消费者的squeue上：static bool SharedQueueDump(SharedQueue squeue, int consumerIdx, TupleTableSlot *tmpslot, Tuplestorestate *tuplestore)
		=》在”src/backend/pgxc/squeue/squeue.c“函数”SharedQueueWrite“、”SharedQueueFinish“中调用
		SharedQueueWrite --> SharedQueueDump --> sq_push_long_tuple；SharedQueueFinish --> SharedQueueDump --> sq_push_long_tuple

	将数据从slot中写入到指定消费者的squeue上，如果tuplestore存在数据则优先将tuplestore中的数据写入squeue：
		void SharedQueueWrite(SharedQueue squeue, int consumerIdx, TupleTableSlot *slot, Tuplestorestate **tuplestore, MemoryContext tmpcxt)
		=》在”src/backend/executor/producerReceiver.c“函数”producerReceiveSlot“中，调用该SharedQueueWrite在”tuple不匹配消费者queue“时，将tuple存储到本地tuplestore

	将指定squeue中的一个row数据提取到tupleslot：bool SharedQueueRead(SharedQueue squeue, int consumerIdx, TupleTableSlot *slot, bool canwait)
		=》在”src/backend/tcop/pquery.c“函数”PortalRun“中，循环调用该函数从queue中获取tuple，直到处理完plan中定义的tuple数目

	将指定的消费者标记为已关闭，丢弃可能已经在squeue中的所有输入：void SharedQueueReset(SharedQueue squeue, int consumerIdx)
		=》在”src/backend/commands/portalcmds.c“函数”PortalCleanup“中，清理portal过程中，本地执行子计划正在生成数据并通过squeue分发时调用；或者清理消费者时调用
		=》在”src/backend/tcop/pquery.c“函数”AdvanceProducingPortal“中，catch到错误时调用
		=》在”src/backend/tcop/pquery.c“函数”cleanupClosedProducers“中，catch到错误时调用

	断开给定squeue的远端消费者：void SharedQueueDisconnectConsumer(const char *sqname)
		=》在”src/backend/commands/prepare.c“函数”DropPreparedStatement“中调用

	重置没有消费者连接的squeue：void SharedQueueResetNotConnected(SharedQueue squeue)
		=》在”src/backend/executor/producerReceiver.c“函数”producerDestroyReceiver“中，squeue使用异常结束时调用
		=》在”src/backend/pgxc/squeue/squeue.c“函数”SharedQueueUnBind“中，超时时调用以实现未连接消费者的重置

	设置超时时间，等待生产者闩锁：bool SharedQueueWaitOnProducerLatch(SharedQueue squeue, long timeout)
		=》在”src/backend/executor/producerReceiver.c“函数”producerDestroyReceiver“中，squeue使用异常结束时进行设置调用

	确定生产者是否可以安全的暂停工作：bool SharedQueueCanPause(SharedQueue squeue)
		=》在”src/backend/tcop/pquery.c“函数”AdvanceProducingPortal“中，当”portal的保留存储中有可供读取的tuple，且消费者queue不为空“时，调用该函数暂停squeue，以防止在生产者处缓存过多的rows
		=》在”src/backend/tcop/pquery.c“函数”AdvanceProducingPortal“中，当”尝试dump本地tuplestores“失败时调用

	squeue使用结束：int SharedQueueFinish(SharedQueue squeue, TupleDesc tupDesc, Tuplestorestate **tuplestore)
		=》在”src/backend/executor/producerReceiver.c“函数”producerDestroyReceiver“中调用
		=》在”src/backend/executor/producerReceiver.c“函数”ProducerReceiverPushBuffers“中，”将data从本地tuplestores推送到共享内存，以供消费者使用“时调用

	解除当前进程和squeue之间的绑定：void SharedQueueUnBind(SharedQueue squeue, bool failed)
		=》在”src/backend/commands/portalcmds.c“函数”PortalCleanup“中，当”executor完成，portal->status == PORTAL_FAILED“时调用
		=》在”src/backend/executor/producerReceiver.c“函数”producerDestroyReceiver“中，当”消费者完成，释放共享资源“时调用
		=》在”src/backend/tcop/pquery.c“函数”PortalStart“中，当“调用SharedQueueBind成功后，调用ExecutorStart失败”进行解绑定时调用

	如果具有指定名称的squeue仍然存在，则将对应的消费者设置为“Done”：void SharedQueueRelease(const char *sqname)
		=》在”src/backend/utils/cache/plancache.c“函数”ReleaseGenericPlan“中，如果持有squeue，则调用该函数进行释放

	后台程序运行结束执行cleanup：void SharedQueuesCleanup(int code, Datum arg)
		=》在“src/backend/tcop/postgres.c”函数“PostgresMain”中，注册该函数，在程序退出时调用

	将数据写入squeue：static bool sq_push_long_tuple(ConsState *cstate, RemoteDataRow datarow)
		=》在”src/backend/pgxc/squeue/squeue.c“函数”SharedQueueDump“中，向消费者queue写入数据时调用

	从squeue读取long tuple：static void sq_pull_long_tuple(ConsState *cstate, RemoteDataRow datarow, int consumerIdx, SQueueSync *sqsync)
		=》在”src/backend/pgxc/squeue/squeue.c“函数”SharedQueueRead“中，至少有一行row数据，需要读取并存储到slot中时调用






（2）================squeue通信执行流程
1、绑定squeue：
在函数”PortalStart“中，
	针对”portal->strategy“为”PORTAL_DISTRIBUTED“的情况下：
		第一步：调用函数”CreateQueryDesc“创建QueryDesc；
		第二步：判断是否避免“single execution”
			是
				第一步：调用函数“RemoteSubplanMakeUnique”确保squeue的名称不重复
				第二步：调用函数“ExecutorStart”
				第三步：调用函数“createLocator”
				第四步：调用函数“CreateDestReceiver”

			否
				第一步：调用函数”SharedQueueBind“指定“portal->name”为名称进行squeue绑定和返回
				第二步：如果作为生产者，依次执行ExecutorStart、createLocator、CreateDestReceiver；如果不是生产者，则执行ExecCleanTypeFromTL


2、构建向squeue写入数据的生产者：
exec_simple_query-->CreateDestReceiver-->CreateProducerDestReceiver
	函数”CreateProducerDestReceiver“如下所示：
		DestReceiver *CreateProducerDestReceiver(void){
			ProducerState *self = (ProducerState *) palloc0(sizeof(ProducerState));
			self->pub.receiveSlot = producerReceiveSlot;
			self->pub.rStartup = producerStartupReceiver;
			self->pub.rShutdown = producerShutdownReceiver;
			self->pub.rDestroy = producerDestroyReceiver;
			self->pub.mydest = DestProducer;

			/* private fields will be set by SetTuplestoreDestReceiverParams */
			self->tcount = 0;
			self->selfcount = 0;
			self->othercount = 0;

			return (DestReceiver *) self;
		}

3、向squeue写入数据
3.1、ExecutePlan-->(*dest->receiveSlot) (slot, dest)
		详细介绍如下所示：static void ExecutePlan(EState *estate, PlanState *planstate,	bool use_parallel_mode,	CmdType operation,	bool sendTuples,
			uint64 numberTuples, ScanDirection direction, DestReceiver *dest, bool execute_once){
				........
				for (;;){
					........
					slot = ExecProcNode(planstate);  //执行plan获取tuple，例如：通过函数指针调用”ExecSeqScan“遍历DN获取数据
					........
					if (sendTuples){     //通过函数指针”receiveSlot“发送tuple存在两种方式，一是”绑定函数printtup“；二是”绑定函数producerReceiveSlot“
						if (!((*dest->receiveSlot) (slot, dest)))     //绑定函数”producerReceiveSlot“，通过"producerReceiveSlot内的SharedQueueWrite"将slot中的tuple写入squeue
							break;
					}
					........
				}
				........
		}


3.2、PortalRun-->(*dest->receiveSlot) (slot, dest)
		详细介绍如下所示：bool PortalRun(Portal portal, long count, bool isTopLevel, bool run_once, DestReceiver *dest, DestReceiver *altdest, char *completionTag){
			bool		result;
			uint64		nprocessed;
			ResourceOwner saveTopTransactionResourceOwner;
			MemoryContext saveTopTransactionContext;
			........
				for (;;){
					.........
					if (TupIsNull(slot)){
						if (!done && producing){
							/* No data to read, advance producing portals */
							ListCell   *lc = list_head(producing);
							while (lc){
								Portal p = (Portal) lfirst(lc);
								/* Get reference to next entry before
									* advancing current portal, because the
									* function may remove current entry from
									* the list.
									*/
								lc = lnext(lc);
								AdvanceProducingPortal(p, false);   //在该函数中，依次调用“ExecutorRun->standard_ExecutorRun->ExecutePlan->producerReceiveSlot->SharedQueueWrite”
							}
							continue;
						}else{
							queryDesc->squeue = NULL;
							break;
						}
					}
					/* Send the tuple */
					(*dest->receiveSlot) (slot, dest);    //绑定函数”printtup“，通过libpq发送tuple
					if (count && count == ++nprocessed)
						break;
				}
				(*dest->rShutdown) (dest);
			........
		}
		在函数“PortalRun”中，执行步骤如下所示：
			第一步：检查portal是否使用不当，并使用函数“MarkPortalActive”将portal标记为“active”状态
			第二步：设置global portal的上下文指针
			第三步：对portal采取的策略(portal->strategy)进行判断，不同策略采用不同的处理方式
				针对“PORTAL_DISTRIBUTED”进行如下处理
					第一步：如果执行的本地subplan用于产生数据并通过squeue进行分发，则进行如下处理：
						判断“portal->queryDesc->squeue”是否为空
							不为空：
								确保生产者正在推进，此时作为生产者，如果“ExecutorFinish不是done”调用函数“AdvanceProducingPortal”执行"portal's query"，并将tuple分发给消费者；调用函数“RunFromStore”（该函数通过dest->receiveSlot绑定函数“printtup”进行tuple发送）从”portal's tuple store“获取tuple

							为空：则调用函数“PortalRunSelect”获取结果的所需部分
					第二步：如果是从squeue中获取数据，则此时作为消费者，进行如下处理：
						第一步：调用函数“MakeSingleTupleTableSlot”，准备一个独立的slot用于接收tuples
						第二步：进入循环处理中，在循环中，调用函数“SharedQueueRead”从squeue中读取数据；当slot为空后，调用函数“AdvanceProducingPortal”执行portal；通过函数指针“dest->receiveSlot”调用绑定的函数“printtup”进行tuple发送
						第三步：通过函数指针“dest->rShutdown”执行绑定函数
						第四步：执行函数“ExecDropSingleTupleTableSlot”释放创建的slot
					第三步：将portal标记为非激活“PORTAL_READY”状态
			第四步：使用catch对捕捉的异常进行处理



4、从squeue读数据
	PortalRun-->SharedQueueRead
		详细介绍如下所示：bool PortalRun(Portal portal, long count, bool isTopLevel, bool run_once, DestReceiver *dest, DestReceiver *altdest, char *completionTag){
			bool		result;
			uint64		nprocessed;
			ResourceOwner saveTopTransactionResourceOwner;
			MemoryContext saveTopTransactionContext;
			........
				for (;;){
					List *producing = getProducingPortals();
					bool done;
					done = SharedQueueRead(squeue, myindex, slot, list_length(producing) == 0);    //直接从squeue中获取tuple
					.........
				}
				(*dest->rShutdown) (dest);
			........
		}



5、squeue清理
在函数”PortalCleanup“中，针对”portal->strategy == PORTAL_DISTRIBUTED“的情况下，调用函数”SharedQueueUnBind“进行squeue解绑定；调用函数”SharedQueueReset“进行squeue清理


（3）================如何确定数据是否应该写入squeue
在函数”ExecutePlan“中，通过函数指针”(*dest->receiveSlot) (slot, dest)“调用”producerReceiveSlot“函数
在文件”src/backend/executor/producerReceiver.c“定义的函数”producerReceiveSlot“用于确定数据是该写入squeue，还是保存在tuplestore
	该函数的介绍如下所示：
		第一步：获取slot中当前tuple的attribute
		第二步：通过函数”GET_NODES“调用”locate_hash_insert“计算数据存储关联的DN
		第三步：进行循环遍历，
			如果生成的数据不用于squeue消费，则通过函数指针”myState->consumer->receiveSlot“调用函数”tstoreReceiveSlot_notoast“将数据存储到tuplestore
			如果生成的数据用于squeue消费，则执行调用函数”SharedQueueWrite“写入到squeue中









（4）================结合日志分析流程
	-----------每个DN会创建作为消费者存在的子进程、作为生产者存在的消费者----------

	创建portal：Created portal p_1_682c_1 and inserted an entry in the has table
	构造subplan：plan p_1_682c_1: Remote Subplan
	创建squeue：Create a new SQueue p_1_682c_1 and format it for 1 consumers
	绑定squeue消费者：Bind node datanode_1 to SQueue p_1_682c_1 as a consumer 54974
	绑定squeue生产者：Bind node datanode_2 to squeue of step p_1_682c_1 as a producer
	创建portal：Created portal p_1_682c_1 and inserted an entry in the has table
	绑定DN：Bind node datanode_1 to squeue of step p_1_682c_1 as a producer
	生产者向squeue写入数据：SQueue p_1_682c_1, consumer is active, writing data
	消费者从squeue读取数据：SQueue p_1_682c_1, consumer (node 0, pid 54973, status 0) - 53 queued tuples to read
	当squeue中不存在tuple供消费者使用时，等待生产者产生数据：
		SQueue p_1_682c_1, consumer (node 0, pid 54973, status 0) - no queued tuples to read, waiting for producer to produce more data
	完成后解绑定：
		SQueue p_1_682c_1, finishing the SQueue - producer node 1, pid 54974, nconsumers 1
		SQueue p_1_682c_1 finishing, consumer at 0, consumer node 0, pid 54973, status 0
		SQueue p_1_682c_1, unbinding the SQueue (failed: F) - producer node 1, pid 54974, nconsumers 1
		SQueue p_1_682c_1 unbinding, check consumer at 0, consumer node 0, pid 54973, status 3





（5）使用SQL语句示例（在CN上使用该语句）
	表创建语句：
		CREATE TABLE t_class(class_id int primary key,class_name varchar(20) not null,Headmaster varchar(20)) distribute by hash(class_id);
		CREATE TABLE t_student(student_id int primary key,name varchar(20) not null,gender varchar(10),age int,class_id int, comment varchar(2000)) distribute by hash(student_id);
		INSERT INTO t_class(class_id,class_name,Headmaster) select n,'班级_'||n,'Headmaster_'||n from generate_series(1,500) n;
		INSERT INTO t_student(student_id,name,gender,age,class_id) select n,'学生_'||n,(case when random()<0.5 then 1 else 2 end ),floor(random()*4+10),floor(random()*500)+1 from generate_series(1,5000) n;

	explain  select * from t_student inner  join t_class on t_class.class_id=t_student.class_id;
													QUERY PLAN
	-------------------------------------------------------------------------------------------------------------
	Remote Subquery Scan on all (datanode_1,datanode_2)  (cost=7.54..58.92 rows=1270 width=569)
	->  Hash Join  (cost=7.54..58.92 rows=1270 width=569)
			Hash Cond: (t_student.class_id = t_class.class_id)
			->  Remote Subquery Scan on all (datanode_1,datanode_2)  (cost=100.00..1542.92 rows=2561 width=541)
				Distribute results by H: class_id
				->  Seq Scan on t_student  (cost=0.00..44.61 rows=2561 width=541)
			->  Hash  (cost=4.46..4.46 rows=246 width=28)
				->  Seq Scan on t_class  (cost=0.00..4.46 rows=246 width=28)              //在DN1中，表t_class的数据行数为246
	(8 rows)


	在执行该sql语句的过程中，进行”Remote Subquery Scan on all (datanode_1,datanode_2) Distribute results by H: class_id“时，涉及使用squeue进行数据交换（即DN1读取本地节点中t_student表的数据字段，并将其写入自己的squeue中，供DN2进行joining时使用；同时DN2读取本地节点中t_student表的数据字段，并将其写入到自己的squeue中，供DN1进行joining时使用）
		1、写入到squeue中的tuple数据，在“ExecRemoteSubplan函数中通过函数pgxc_node_send_execute使用tcp发送portal”，在其它进程收到portal并执行时，通过函数”printtup“依据”版本3.0的协议，添加标识符D，包装成Data Row“进行数据传输；在这一过程中是DN1与DN2之间的直接通信，不涉及与CN的数据交互
		2、由于存在join条件”t_student.class_id = t_class.class_id“，故可以通过应用”hash distribution function“定位与”t_class.class_id“进行join的t_student数据字段最终是存到DN1还是DN2上
		3、在DN1中scan表t_student后的数据分两部分存储，一部分用于和DN2中的t_class进行join，这部分数据存储到DN1中的squeue中；另一部分用于和DN1中的t_class进行join，就存储在DN1中的tuplestore中
		4、在DN2中，t_student数据分两类，“类1”用于和DN1中t_class进行join，“类2”用于和DN2中t_class进行join；进程19937通过“pgxc_node_send_execute”分别向DN1和DN2发送待执行的portal（例如p_1_bc47_1）；进程19943在收到待执行的portal时，先作为生产者将"类1"数据写入squeue，并随后将“类2”数据使用“printtup”函数发送给DN2；进程19949在收到待执行的portal时，作为消费者读取squeue数据并使用函数“printtup”进行数据发送（即负责将“类1”数据发送给DN1）;
		5、在DN2中，进程19937分别与DN1、DN2建立socket连接，通过ExecRemoteSubplan执行子计划、pgxc_node_send_execute执行portal、pgxc_node_send_flush开始传输数据、pgxc_node_receive获取t_student数据；在执行成功后drop portal；最后使用函数“pgxc_node_send_query”依次发送“COMMIT TRANSACTION”提交事务、“RESET ALL;RESET SESSION AUTHORIZATION;RESET transaction_isolation;RESET global_session”重置远程query；
		6、在DN2中，进程19943进行远程query协议的bind操作，执行函数”exec_bind_message-->PortalStart-->SharedQueueBind“进行绑定设置；进程19943通过函数“exec_execute_message“执行portal，在执行portal过程中，通过”PortalRun-->AdvanceProducingPortal-->ExecutorRun-->standard_ExecutorRun-->ExecutorPlan“先执行”ExecProcNode-->.....-->ExecSeqScan“对表t_student进行遍历，获取一行数据，并调用函数”producerReceiveSlot“对该数据进行处理（一是调用”SharedQueueWrite“写入到squeue中；二是调用”tstoreReceiveSlot_notoast“写入到tuplestore，即portal->holdStore），再通过”PortalRun-->RunFromStore“最终调用”printtup“将”portal's tuple store“中存储的t_student数据进行网络发送；完成数据传输后drop portal、unbind squeue；
		7、在DN2中，进程19943进行远程query协议的bind操作，执行函数”exec_bind_message-->PortalStart-->SharedQueueBind“进行绑定设置；进程19949执行”exec_bind_message“；进程19949通过函数“exec_execute_message“执行portal，在执行portal过程中，通过”PortalRun-->for(;;)-->SharedQueueRead“从squeue中读取t_student数据，并在之后通过函数指针”(*dest->receiveSlot)“调用函数”printtup“对数据进行网络发送；进程19949收到”H“消息，执行”pq_flush()“；完成后drop portal；
	在整个sql语句执行过程中：
		向squeue写入数据不是一次性将所有class_id数据写入，而是分多次写入
		从squeue中读取class_id数据时，也是多次读取，一旦squeue中没有数据就进行等待
		DN1的涉及的处理
			DN1将本地节点中表t_student的数据字段写入进自己的squeue中，并读取DN2节点中squeue的数据；DN1对本地节点中表t_student和t_class依据class_id进行join操作；DN2对本地节点表t_class和从squeue获取的数据依据class_id进行join操作；最后依次返回join的结果。
			DN1在从squeue中读取表t_student数据时，也是多次读取，一旦squeue中没有数据就进行等待。

		DN2的涉及的处理
			DN2将本地节点中表t_student的数据字段写入进自己的squeue中（不是一次性将所有class_id数据写入，而是分多次写入），并读取DN1节点中squeue的数据；DN2对本地节点中表t_student和t_class依据class_id进行join操作；DN1对本地节点表t_class和从squeue获取的数据依据class_id进行join操作；最后依次返回join的结果。


进程变化：
	使用命令”./psql -p 5432 -d postgres“连接CN1时，CN1创建子进程和其进行交互。
	在”psql“中输入sql语句”select * from t_student inner  join t_class on t_class.class_id=t_student.class_id“，DN1、DN2分别创建如下三个子进程
		zq       16498 12143  0 16:02 ?        00:00:00 postgres: zq postgres ::1(50030) idle
		zq       16503 12144  0 16:02 ?        00:00:00 postgres: zq postgres ::1(38548) idle
		zq       17020 12143  0 16:04 ?        00:00:00 postgres: zq postgres ::1(50062) idle
		zq       17022 12144  0 16:04 ?        00:00:00 postgres: zq postgres ::1(38574) idle
		zq       17381 12143  0 16:04 ?        00:00:00 postgres: zq postgres ::1(50070) idle
		zq       17383 12144  0 16:04 ?        00:00:00 postgres: zq postgres ::1(38582) idle

	在进程”16503“中调试”PortalRun“的过程中，进程状态变化如下：
		zq       16498 12143  0 16:02 ?        00:00:00 postgres: zq postgres ::1(50030) REMOTE SUBPLAN (coord1:41718) (D:datanode_2:17022)
		zq       16503 12144  0 16:02 ?        00:00:00 postgres: zq postgres ::1(38548) REMOTE SUBPLAN (coord1:41718) (D:datanode_2:17022)
		zq       17020 12143  0 16:04 ?        00:00:00 postgres: zq postgres ::1(50062) REMOTE SUBPLAN (coord1:41718) (C:coord1:41718)
		zq       17022 12144  0 16:04 ?        00:00:00 postgres: zq postgres ::1(38574) REMOTE SUBPLAN (coord1:41718) (C:coord1:41718)
		zq       17381 12143  0 16:04 ?        00:00:00 postgres: zq postgres ::1(50070) REMOTE SUBPLAN (coord1:41718) (D:datanode_1:17020)
		zq       17383 12144  0 16:04 ?        00:00:00 postgres: zq postgres ::1(38582) REMOTE SUBPLAN (coord1:41718) (D:datanode_1:17020)

		zq       16498 12143  0 16:02 ?        00:00:00 postgres: zq postgres ::1(50030) idle
		zq       16503 12144  0 16:02 ?        00:00:00 postgres: zq postgres ::1(38548) RESET
		zq       17020 12143  0 16:04 ?        00:00:00 postgres: zq postgres ::1(50062) idle
		zq       17022 12144  0 16:04 ?        00:00:00 postgres: zq postgres ::1(38574) COMMIT
		zq       17381 12143  0 16:04 ?        00:00:00 postgres: zq postgres ::1(50070) idle
		zq       17383 12144  0 16:04 ?        00:00:00 postgres: zq postgres ::1(38582) idle




涉及squeue的子执行计划示例如下所示：共有四个执行计划“Fp_1_d6ab_4.Remote Subplan”、“Fp_1_d6ab_2.Remote Subplan”、“p_1_d6ab_3.Remote Subplan”、“p_1_d6ab_1.Remote Subplan”
	1、其中执行计划“Fp_1_d6ab_4.Remote Subplan”和“Fp_1_d6ab_2.Remote Subplan”除了“子计划名称”、“cursor的值”不同，其它内容相同；子计划“p_1_d6ab_3.Remote Subplan”和“p_1_d6ab_1.Remote Subplan”除了“子计划名称”不同，其它内容都相同
	2、在“Fp_1_d6ab_4.Remote Subplan”中，”distributionType H: distributionKey 5: ................: nodeList(i 0 1): execOnAll true: sort < >: cursor p_1_d6ab_3: unique 0“表示涉及重分布，对于“cursor”的设置由“src/backend/optimizer/plan/createplan.c”中函数“get_internal_cursor”完成设置，该”cursor“的名称同”portal的名称“、”squeue的名称“、“子执行计划名称”相关联。
	3、各执行计划具体内容如下所示：
		Fp_1_d6ab_4.Remote Subplan. {
			REMOTESTMT: commandType 1: hasReturning false: parallelModeNeeded false: planTree {
				HASHJOIN: startup_cost 7.54: total_cost 21.48: plan_rows 307: plan_width 568: parallel_aware false: parallel_safe true: plan_node_id 1: targetlist({
					TARGETENTRY: expr {
						VAR: varno 65001: varattno 1: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 1: location 7
					}: resno 1: resname student_id: ressortgroupref 0: resorigtbl public t_student: resorigcol 1: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 65001: varattno 2: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
						default -1: varlevelsup 0: varnoold 1: varoattno 2: location 7
					}: resno 2: resname name: ressortgroupref 0: resorigtbl public t_student: resorigcol 2: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 65001: varattno 3: vartype pg_catalog varchar: vartypmod 14: varcollid pg_catalog
						default -1: varlevelsup 0: varnoold 1: varoattno 3: location 7
					}: resno 3: resname gender: ressortgroupref 0: resorigtbl public t_student: resorigcol 3: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 65001: varattno 4: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 4: location 7
					}: resno 4: resname age: ressortgroupref 0: resorigtbl public t_student: resorigcol 4: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 65001: varattno 5: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 5: location 7
					}: resno 5: resname class_id: ressortgroupref 0: resorigtbl public t_student: resorigcol 5: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 65001: varattno 6: vartype pg_catalog varchar: vartypmod 2004: varcollid pg_catalog
						default -1: varlevelsup 0: varnoold 1: varoattno 6: location 7
					}: resno 6: resname comment: ressortgroupref 0: resorigtbl public t_student: resorigcol 6: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 65000: varattno 1: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 2: varoattno 1: location 7
					}: resno 7: resname class_id: ressortgroupref 0: resorigtbl public t_class: resorigcol 1: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 65000: varattno 2: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
						default -1: varlevelsup 0: varnoold 2: varoattno 2: location 7
					}: resno 8: resname class_name: ressortgroupref 0: resorigtbl public t_class: resorigcol 2: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 65000: varattno 3: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
						default -1: varlevelsup 0: varnoold 2: varoattno 3: location 7
					}: resno 9: resname headmaster: ressortgroupref 0: resorigtbl public t_class: resorigcol 3: resjunk false
				}): qual < >: lefttree {
					REMOTESUBPLAN: startup_cost 100.00: total_cost 381.50: plan_rows 500: plan_width 540: parallel_aware false: parallel_safe false: plan_node_id 2: targetlist({
						TARGETENTRY: expr {
							VAR: varno 1: varattno 1: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 1: location 7
						}: resno 1: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					} {
						TARGETENTRY: expr {
							VAR: varno 1: varattno 2: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
							default -1: varlevelsup 0: varnoold 1: varoattno 2: location 7
						}: resno 2: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					} {
						TARGETENTRY: expr {
							VAR: varno 1: varattno 3: vartype pg_catalog varchar: vartypmod 14: varcollid pg_catalog
							default -1: varlevelsup 0: varnoold 1: varoattno 3: location 7
						}: resno 3: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					} {
						TARGETENTRY: expr {
							VAR: varno 1: varattno 4: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 4: location 7
						}: resno 4: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					} {
						TARGETENTRY: expr {
							VAR: varno 1: varattno 5: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 5: location 7
						}: resno 5: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					} {
						TARGETENTRY: expr {
							VAR: varno 1: varattno 6: vartype pg_catalog varchar: vartypmod 2004: varcollid pg_catalog
							default -1: varlevelsup 0: varnoold 1: varoattno 6: location 7
						}: resno 6: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					}): qual < >: lefttree {
						SEQSCAN: startup_cost 0.00: total_cost 9.00: plan_rows 500: plan_width 540: parallel_aware false: parallel_safe true: plan_node_id 3: targetlist({
							TARGETENTRY: expr {
								VAR: varno 1: varattno 1: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 1: location 7
							}: resno 1: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						} {
							TARGETENTRY: expr {
								VAR: varno 1: varattno 2: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
								default -1: varlevelsup 0: varnoold 1: varoattno 2: location 7
							}: resno 2: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						} {
							TARGETENTRY: expr {
								VAR: varno 1: varattno 3: vartype pg_catalog varchar: vartypmod 14: varcollid pg_catalog
								default -1: varlevelsup 0: varnoold 1: varoattno 3: location 7
							}: resno 3: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						} {
							TARGETENTRY: expr {
								VAR: varno 1: varattno 4: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 4: location 7
							}: resno 4: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						} {
							TARGETENTRY: expr {
								VAR: varno 1: varattno 5: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 5: location 7
							}: resno 5: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						} {
							TARGETENTRY: expr {
								VAR: varno 1: varattno 6: vartype pg_catalog varchar: vartypmod 2004: varcollid pg_catalog
								default -1: varlevelsup 0: varnoold 1: varoattno 6: location 7
							}: resno 6: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						}): qual < >: lefttree < >: righttree < >: initPlan < >: extParam(b): allParam(b): scanrelid 1
					}: righttree < >: initPlan < >: extParam(b): allParam(b): scanrelid 0: distributionType H: distributionKey 5: distributionNodes(i 0 1): distributionRestrict(i 0 1): nodeList(i 0 1): execOnAll true: sort < >: cursor p_1_d6ab_3: unique 0
				}: righttree {
					HASH: startup_cost 4.46: total_cost 4.46: plan_rows 246: plan_width 28: parallel_aware false: parallel_safe true: plan_node_id 4: targetlist({
						TARGETENTRY: expr {
							VAR: varno 65001: varattno 1: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 2: varoattno 1: location - 1
						}: resno 1: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					} {
						TARGETENTRY: expr {
							VAR: varno 65001: varattno 2: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
							default -1: varlevelsup 0: varnoold 2: varoattno 2: location - 1
						}: resno 2: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					} {
						TARGETENTRY: expr {
							VAR: varno 65001: varattno 3: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
							default -1: varlevelsup 0: varnoold 2: varoattno 3: location - 1
						}: resno 3: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					}): qual < >: lefttree {
						SEQSCAN: startup_cost 0.00: total_cost 4.46: plan_rows 246: plan_width 28: parallel_aware false: parallel_safe true: plan_node_id 5: targetlist({
							TARGETENTRY: expr {
								VAR: varno 2: varattno 1: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 2: varoattno 1: location 7
							}: resno 1: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						} {
							TARGETENTRY: expr {
								VAR: varno 2: varattno 2: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
								default -1: varlevelsup 0: varnoold 2: varoattno 2: location 7
							}: resno 2: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						} {
							TARGETENTRY: expr {
								VAR: varno 2: varattno 3: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
								default -1: varlevelsup 0: varnoold 2: varoattno 3: location 7
							}: resno 3: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						}): qual < >: lefttree < >: righttree < >: initPlan < >: extParam(b): allParam(b): scanrelid 2
					}: righttree < >: initPlan < >: extParam(b): allParam(b): skewTable public t_student: skewColumn 5: skewInherit false
				}: initPlan < >: extParam(b): allParam(b): jointype 0: inner_unique false: joinqual < >: hashclauses({
					OPEXPR: opno pg_catalog = pg_catalog int4 pg_catalog int4: opfuncid pg_catalog int4eq 2 pg_catalog int4 pg_catalog int4: opresulttype pg_catalog bool: opretset false: opcollid < > < > -1: inputcollid < > < > -1: args({
						VAR: varno 65001: varattno 5: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 5: location 41
					} {
						VAR: varno 65000: varattno 1: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 2: varoattno 1: location 60
					}): location - 1
				})
			}: rtable({
				RTE: alias < >: eref {
					ALIAS: aliasname t_student: colnames("student_id"
						"name"
						"gender"
						"age"
						"class_id"
						"comment")
				}: rtekind 0: relkind r: relid public t_student: tablesample < >: lateral false: inh false: inFromCl true: requiredPerms 2: checkAsUser 0: selectedCols(b 10 11 12 13 14 15): insertedCols(b): updatedCols(b): securityQuals < >
			} {
				RTE: alias < >: eref {
					ALIAS: aliasname t_class: colnames("class_id"
						"class_name"
						"headmaster")
				}: rtekind 0: relkind r: relid public t_class: tablesample < >: lateral false: inh false: inFromCl true: requiredPerms 2: checkAsUser 0: selectedCols(b 10 11 12): insertedCols(b): updatedCols(b): securityQuals < >
			} {
				RTE: alias < >: eref {
					ALIAS: aliasname unnamed_join: colnames("student_id"
						"name"
						"gender"
						"age"
						"class_id"
						"comment"
						"class_id"
						"class_name"
						"headmaster")
				}: rtekind 2: jointype 0: joinaliasvars < >: lateral false: inh false: inFromCl true: requiredPerms 2: checkAsUser 0: selectedCols(b): insertedCols(b): updatedCols(b): securityQuals < >
			}): resultRelations < >: subplans < >: nParamExec 0: nParamRemote 0: rowMarks < >: distributionType O: distributionKey 0: distributionNodes < >: distributionRestrict < >
		}


		Fp_1_d6ab_2.Remote Subplan. {
			REMOTESTMT: commandType 1: hasReturning false: parallelModeNeeded false: planTree {
				HASHJOIN: startup_cost 7.54: total_cost 21.48: plan_rows 307: plan_width 568: parallel_aware false: parallel_safe true: plan_node_id 1: targetlist({
					TARGETENTRY: expr {
						VAR: varno 65001: varattno 1: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 1: location 7
					}: resno 1: resname student_id: ressortgroupref 0: resorigtbl public t_student: resorigcol 1: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 65001: varattno 2: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
						default -1: varlevelsup 0: varnoold 1: varoattno 2: location 7
					}: resno 2: resname name: ressortgroupref 0: resorigtbl public t_student: resorigcol 2: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 65001: varattno 3: vartype pg_catalog varchar: vartypmod 14: varcollid pg_catalog
						default -1: varlevelsup 0: varnoold 1: varoattno 3: location 7
					}: resno 3: resname gender: ressortgroupref 0: resorigtbl public t_student: resorigcol 3: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 65001: varattno 4: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 4: location 7
					}: resno 4: resname age: ressortgroupref 0: resorigtbl public t_student: resorigcol 4: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 65001: varattno 5: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 5: location 7
					}: resno 5: resname class_id: ressortgroupref 0: resorigtbl public t_student: resorigcol 5: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 65001: varattno 6: vartype pg_catalog varchar: vartypmod 2004: varcollid pg_catalog
						default -1: varlevelsup 0: varnoold 1: varoattno 6: location 7
					}: resno 6: resname comment: ressortgroupref 0: resorigtbl public t_student: resorigcol 6: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 65000: varattno 1: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 2: varoattno 1: location 7
					}: resno 7: resname class_id: ressortgroupref 0: resorigtbl public t_class: resorigcol 1: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 65000: varattno 2: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
						default -1: varlevelsup 0: varnoold 2: varoattno 2: location 7
					}: resno 8: resname class_name: ressortgroupref 0: resorigtbl public t_class: resorigcol 2: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 65000: varattno 3: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
						default -1: varlevelsup 0: varnoold 2: varoattno 3: location 7
					}: resno 9: resname headmaster: ressortgroupref 0: resorigtbl public t_class: resorigcol 3: resjunk false
				}): qual < >: lefttree {
					REMOTESUBPLAN: startup_cost 100.00: total_cost 381.50: plan_rows 500: plan_width 540: parallel_aware false: parallel_safe false: plan_node_id 2: targetlist({
						TARGETENTRY: expr {
							VAR: varno 1: varattno 1: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 1: location 7
						}: resno 1: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					} {
						TARGETENTRY: expr {
							VAR: varno 1: varattno 2: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
							default -1: varlevelsup 0: varnoold 1: varoattno 2: location 7
						}: resno 2: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					} {
						TARGETENTRY: expr {
							VAR: varno 1: varattno 3: vartype pg_catalog varchar: vartypmod 14: varcollid pg_catalog
							default -1: varlevelsup 0: varnoold 1: varoattno 3: location 7
						}: resno 3: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					} {
						TARGETENTRY: expr {
							VAR: varno 1: varattno 4: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 4: location 7
						}: resno 4: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					} {
						TARGETENTRY: expr {
							VAR: varno 1: varattno 5: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 5: location 7
						}: resno 5: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					} {
						TARGETENTRY: expr {
							VAR: varno 1: varattno 6: vartype pg_catalog varchar: vartypmod 2004: varcollid pg_catalog
							default -1: varlevelsup 0: varnoold 1: varoattno 6: location 7
						}: resno 6: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					}): qual < >: lefttree {
						SEQSCAN: startup_cost 0.00: total_cost 9.00: plan_rows 500: plan_width 540: parallel_aware false: parallel_safe true: plan_node_id 3: targetlist({
							TARGETENTRY: expr {
								VAR: varno 1: varattno 1: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 1: location 7
							}: resno 1: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						} {
							TARGETENTRY: expr {
								VAR: varno 1: varattno 2: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
								default -1: varlevelsup 0: varnoold 1: varoattno 2: location 7
							}: resno 2: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						} {
							TARGETENTRY: expr {
								VAR: varno 1: varattno 3: vartype pg_catalog varchar: vartypmod 14: varcollid pg_catalog
								default -1: varlevelsup 0: varnoold 1: varoattno 3: location 7
							}: resno 3: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						} {
							TARGETENTRY: expr {
								VAR: varno 1: varattno 4: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 4: location 7
							}: resno 4: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						} {
							TARGETENTRY: expr {
								VAR: varno 1: varattno 5: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 5: location 7
							}: resno 5: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						} {
							TARGETENTRY: expr {
								VAR: varno 1: varattno 6: vartype pg_catalog varchar: vartypmod 2004: varcollid pg_catalog
								default -1: varlevelsup 0: varnoold 1: varoattno 6: location 7
							}: resno 6: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						}): qual < >: lefttree < >: righttree < >: initPlan < >: extParam(b): allParam(b): scanrelid 1
					}: righttree < >: initPlan < >: extParam(b): allParam(b): scanrelid 0: distributionType H: distributionKey 5: distributionNodes(i 0 1): distributionRestrict(i 0 1): nodeList(i 0 1): execOnAll true: sort < >: cursor p_1_d6ab_1: unique 0
				}: righttree {
					HASH: startup_cost 4.46: total_cost 4.46: plan_rows 246: plan_width 28: parallel_aware false: parallel_safe true: plan_node_id 4: targetlist({
						TARGETENTRY: expr {
							VAR: varno 65001: varattno 1: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 2: varoattno 1: location - 1
						}: resno 1: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					} {
						TARGETENTRY: expr {
							VAR: varno 65001: varattno 2: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
							default -1: varlevelsup 0: varnoold 2: varoattno 2: location - 1
						}: resno 2: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					} {
						TARGETENTRY: expr {
							VAR: varno 65001: varattno 3: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
							default -1: varlevelsup 0: varnoold 2: varoattno 3: location - 1
						}: resno 3: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
					}): qual < >: lefttree {
						SEQSCAN: startup_cost 0.00: total_cost 4.46: plan_rows 246: plan_width 28: parallel_aware false: parallel_safe true: plan_node_id 5: targetlist({
							TARGETENTRY: expr {
								VAR: varno 2: varattno 1: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 2: varoattno 1: location 7
							}: resno 1: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						} {
							TARGETENTRY: expr {
								VAR: varno 2: varattno 2: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
								default -1: varlevelsup 0: varnoold 2: varoattno 2: location 7
							}: resno 2: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						} {
							TARGETENTRY: expr {
								VAR: varno 2: varattno 3: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
								default -1: varlevelsup 0: varnoold 2: varoattno 3: location 7
							}: resno 3: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
						}): qual < >: lefttree < >: righttree < >: initPlan < >: extParam(b): allParam(b): scanrelid 2
					}: righttree < >: initPlan < >: extParam(b): allParam(b): skewTable public t_student: skewColumn 5: skewInherit false
				}: initPlan < >: extParam(b): allParam(b): jointype 0: inner_unique false: joinqual < >: hashclauses({
					OPEXPR: opno pg_catalog = pg_catalog int4 pg_catalog int4: opfuncid pg_catalog int4eq 2 pg_catalog int4 pg_catalog int4: opresulttype pg_catalog bool: opretset false: opcollid < > < > -1: inputcollid < > < > -1: args({
						VAR: varno 65001: varattno 5: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 5: location 41
					} {
						VAR: varno 65000: varattno 1: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 2: varoattno 1: location 60
					}): location - 1
				})
			}: rtable({
				RTE: alias < >: eref {
					ALIAS: aliasname t_student: colnames("student_id"
						"name"
						"gender"
						"age"
						"class_id"
						"comment")
				}: rtekind 0: relkind r: relid public t_student: tablesample < >: lateral false: inh false: inFromCl true: requiredPerms 2: checkAsUser 0: selectedCols(b 10 11 12 13 14 15): insertedCols(b): updatedCols(b): securityQuals < >
			} {
				RTE: alias < >: eref {
					ALIAS: aliasname t_class: colnames("class_id"
						"class_name"
						"headmaster")
				}: rtekind 0: relkind r: relid public t_class: tablesample < >: lateral false: inh false: inFromCl true: requiredPerms 2: checkAsUser 0: selectedCols(b 10 11 12): insertedCols(b): updatedCols(b): securityQuals < >
			} {
				RTE: alias < >: eref {
					ALIAS: aliasname unnamed_join: colnames("student_id"
						"name"
						"gender"
						"age"
						"class_id"
						"comment"
						"class_id"
						"class_name"
						"headmaster")
				}: rtekind 2: jointype 0: joinaliasvars < >: lateral false: inh false: inFromCl true: requiredPerms 2: checkAsUser 0: selectedCols(b): insertedCols(b): updatedCols(b): securityQuals < >
			}): resultRelations < >: subplans < >: nParamExec 0: nParamRemote 0: rowMarks < >: distributionType O: distributionKey 0: distributionNodes < >: distributionRestrict < >
		}


		p_1_d6ab_3.Remote Subplan. {
			REMOTESTMT: commandType 1: hasReturning false: parallelModeNeeded false: planTree {
				SEQSCAN: startup_cost 0.00: total_cost 9.00: plan_rows 500: plan_width 540: parallel_aware false: parallel_safe true: plan_node_id 3: targetlist({
					TARGETENTRY: expr {
						VAR: varno 1: varattno 1: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 1: location - 1
					}: resno 1: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 1: varattno 2: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
						default -1: varlevelsup 0: varnoold 1: varoattno 2: location - 1
					}: resno 2: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 1: varattno 3: vartype pg_catalog varchar: vartypmod 14: varcollid pg_catalog
						default -1: varlevelsup 0: varnoold 1: varoattno 3: location - 1
					}: resno 3: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 1: varattno 4: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 4: location - 1
					}: resno 4: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 1: varattno 5: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 5: location - 1
					}: resno 5: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 1: varattno 6: vartype pg_catalog varchar: vartypmod 2004: varcollid pg_catalog
						default -1: varlevelsup 0: varnoold 1: varoattno 6: location - 1
					}: resno 6: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
				}): qual < >: lefttree < >: righttree < >: initPlan < >: extParam(b): allParam(b): scanrelid 1
			}: rtable({
				RTE: alias < >: eref {
					ALIAS: aliasname t_student: colnames("student_id"
						"name"
						"gender"
						"age"
						"class_id"
						"comment")
				}: rtekind 0: relkind r: relid public t_student: tablesample < >: lateral false: inh false: inFromCl true: requiredPerms 0: checkAsUser 0: selectedCols(b 10 11 12 13 14 15): insertedCols(b): updatedCols(b): securityQuals < >
			} {
				RTE: alias < >: eref {
					ALIAS: aliasname t_class: colnames("class_id"
						"class_name"
						"headmaster")
				}: rtekind 0: relkind r: relid public t_class: tablesample < >: lateral false: inh false: inFromCl true: requiredPerms 0: checkAsUser 0: selectedCols(b 10 11 12): insertedCols(b): updatedCols(b): securityQuals < >
			} {
				RTE: alias < >: eref {
					ALIAS: aliasname unnamed_join: colnames("student_id"
						"name"
						"gender"
						"age"
						"class_id"
						"comment"
						"class_id"
						"class_name"
						"headmaster")
				}: rtekind 2: jointype 0: joinaliasvars < >: lateral false: inh false: inFromCl true: requiredPerms 0: checkAsUser 0: selectedCols(b): insertedCols(b): updatedCols(b): securityQuals < >
			}): resultRelations < >: subplans < >: nParamExec 0: nParamRemote 0: rowMarks < >: distributionType H: distributionKey 5: distributionNodes(i 0 1): distributionRestrict(i 0 1)
		}


		p_1_d6ab_1.Remote Subplan. {
			REMOTESTMT: commandType 1: hasReturning false: parallelModeNeeded false: planTree {
				SEQSCAN: startup_cost 0.00: total_cost 9.00: plan_rows 500: plan_width 540: parallel_aware false: parallel_safe true: plan_node_id 3: targetlist({
					TARGETENTRY: expr {
						VAR: varno 1: varattno 1: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 1: location - 1
					}: resno 1: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 1: varattno 2: vartype pg_catalog varchar: vartypmod 24: varcollid pg_catalog
						default -1: varlevelsup 0: varnoold 1: varoattno 2: location - 1
					}: resno 2: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 1: varattno 3: vartype pg_catalog varchar: vartypmod 14: varcollid pg_catalog
						default -1: varlevelsup 0: varnoold 1: varoattno 3: location - 1
					}: resno 3: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 1: varattno 4: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 4: location - 1
					}: resno 4: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 1: varattno 5: vartype pg_catalog int4: vartypmod - 1: varcollid < > < > -1: varlevelsup 0: varnoold 1: varoattno 5: location - 1
					}: resno 5: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
				} {
					TARGETENTRY: expr {
						VAR: varno 1: varattno 6: vartype pg_catalog varchar: vartypmod 2004: varcollid pg_catalog
						default -1: varlevelsup 0: varnoold 1: varoattno 6: location - 1
					}: resno 6: resname < >: ressortgroupref 0: resorigtbl < > < >: resorigcol 0: resjunk false
				}): qual < >: lefttree < >: righttree < >: initPlan < >: extParam(b): allParam(b): scanrelid 1
			}: rtable({
				RTE: alias < >: eref {
					ALIAS: aliasname t_student: colnames("student_id"
						"name"
						"gender"
						"age"
						"class_id"
						"comment")
				}: rtekind 0: relkind r: relid public t_student: tablesample < >: lateral false: inh false: inFromCl true: requiredPerms 0: checkAsUser 0: selectedCols(b 10 11 12 13 14 15): insertedCols(b): updatedCols(b): securityQuals < >
			} {
				RTE: alias < >: eref {
					ALIAS: aliasname t_class: colnames("class_id"
						"class_name"
						"headmaster")
				}: rtekind 0: relkind r: relid public t_class: tablesample < >: lateral false: inh false: inFromCl true: requiredPerms 0: checkAsUser 0: selectedCols(b 10 11 12): insertedCols(b): updatedCols(b): securityQuals < >
			} {
				RTE: alias < >: eref {
					ALIAS: aliasname unnamed_join: colnames("student_id"
						"name"
						"gender"
						"age"
						"class_id"
						"comment"
						"class_id"
						"class_name"
						"headmaster")
				}: rtekind 2: jointype 0: joinaliasvars < >: lateral false: inh false: inFromCl true: requiredPerms 0: checkAsUser 0: selectedCols(b): insertedCols(b): updatedCols(b): securityQuals < >
			}): resultRelations < >: subplans < >: nParamExec 0: nParamRemote 0: rowMarks < >: distributionType H: distributionKey 5: distributionNodes(i 0 1): distributionRestrict(i 0 1)
		}






参考链接：https://dba.stackexchange.com/questions/73492/postgres-xc-and-mpp
